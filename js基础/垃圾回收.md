#### 前言
JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存

#### 什么是垃圾
一般来说没有被引用的对象就是垃圾（访问不到），就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。

例如
```js
// 1
let user = {
    name: 'john'
}
user = null // 此时john这个对象已经没有变量引用，因此就成了垃圾，等待被回收

// 2
let user = {
    name: 'kele'
}
let admin = user
user = null
// 此时kele这个对象还不能被回收，虽然user对他没有引用了，但是admin对他还有引用
```

#### 垃圾回收算法
基本的垃圾回收算法为“标记-清除”， “引用计数”，定期执行垃圾回收

##### 引用计数
实现原理

内部通过引用计数器，来维护当前对象的引用数，从而判断该对象的引用数是否为0，来决定它是否是一个垃圾对象。如果引用数值为0,GC就开始工作，将其所在的内存空间进行回收释放和再使用

引用计数器

当某一个对象的引用关系发生改变时，引用计数器就会自动的修改这个对象所对应的引用数值（比如我们代码中有一个对象空间，一个变量引用了它，那么这个对象空间的引用数值加1） 引用数值为0的时候GC就开始工作，将当前的对象空间回收

引用计数的优点
* 可以即时回收垃圾对象、减少程序卡顿时间。
* 发现垃圾立即回收(因为根据当前的引用数值是否为0判断他是否是一个垃圾，如果是垃圾就回收内存空间，释放内存)
* 最大限度的减少程序暂停（应用程序在执行的过程中必定会对内存进行消耗，而当前的执行平台内存空间是有上限的，所以内存肯定会有占满的时候。由于引用计数算法时刻监控着那些引用数值为0的对象，当内存爆满的时候会去找那些引用数值为0的对象释放其内存，这个也就保证了当前的内存空间不会有占满的时候）

引用计数的缺点
* 无法回收循环引用的对象、资源消耗较大
* 无法回收循环引用的对象
* 时间开销大（当前的引用计数需要去维护一个数值的变化，时刻监控当前引用数值是否修改，修改需要时间）

##### 标记清除
1. 标记空间中「可达」值

V8采用的是可达性 (reachability) 算法来判断堆中的对象应不应该被回收。

* 从根节点（Root）出发，遍历所有的对象。
* 可以遍历到的对象，是可达的（reachable）。
* 没有被遍历到的对象，不可达的（unreachable）。
* 在浏览器环境下，根节点有很多，主要包括这几种（全局变量 window，位于每个iframe中文档 DOM 树，存放在栈上的变量）

2. 回收 不可达 的值占用的内存

在所有的标记完成之后，统一清理内存中所有不可达的对象。

3. 做内存整理
* 在频繁回收对象后，内存中就会存在大量不连续空间，专业名词叫「内存碎片」。
* 当内存中出现了大量的内存碎片，如果需要分配较大的连续内存时，就有可能出现内存不足的情况。
* 所以最后一步是整理内存碎片。(但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。)

#### 垃圾回收机制优化
1. 分代收集

浏览器将数据分为两种，一种是「临时」对象，一种是「长久」对象

临时对象：大部分对象在内存中存活的时间很短。（比如函数内部声明的变量，或者块级作用域中的变量。当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。）这类对象很快就变得不可访问，应该快点回收。

长久对象：生命周期很长的对象，比如全局的 window、DOM、Web API 等等。这类对象可以慢点回收。

这两种对象对应不同的回收策略，所以，V8 把堆分为新生代和老生代两个区域， 新生代中存放临时对象，老生代中存放持久对象。并且让副垃圾回收器、主垃圾回收器，分别负责新生代、老生代的垃圾回收。这样就可以实现高效的垃圾回收啦。

**主垃圾回收器**

负责老生代的垃圾回收，有两个特点：

* 对象占用空间大。
* 对象存活时间长。

垃圾回收过程： 它使用「标记-清除」的算法执行垃圾回收。首先是标记，从一组根元素开始，递归遍历这组根元素， 在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据；然后是垃圾清除，直接将标记为垃圾的数据清理掉；多次标记-清除后，会产生大量不连续的内存碎片，需要进行内存整理，将活动对象整理到一起，整理出大片连续的内存空间。
![](https://img-blog.csdnimg.cn/20201011152140847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI5NTI2Mg==,size_16,color_FFFFFF,t_70#pic_center)

**副垃圾回收器**

负责新生代的垃圾回收，通常只支持 1~8 M 的容量。新生代被分为两个区域：一般是对象区域，一半是空闲区域。新加入的对象都被放入对象区域，等对象区域快满的时候，会执行一次垃圾清理。
![](https://img-blog.csdnimg.cn/20201011152217646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI5NTI2Mg==,size_16,color_FFFFFF,t_70#pic_center)

垃圾回收过程：先给对象区域所有垃圾（不可达，访问不到）做标记。标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍。这就回到我们前面留下的问题 – 副垃圾回收器没有碎片整理。因为空闲区域里此时是有序的，没有碎片，也就不需要整理了。复制完成后，对象区域会和空闲区域进行对调。将空闲区域中存活的对象放入对象区域里。这样，就完成了垃圾回收。因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置得比较小。一旦检测到空间装满了，就执行垃圾回收
![](https://img-blog.csdnimg.cn/20201011152249210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI5NTI2Mg==,size_16,color_FFFFFF,t_70#pic_center)
![](https://img-blog.csdnimg.cn/20201011152306303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI5NTI2Mg==,size_16,color_FFFFFF,t_70#pic_center)

2. 增量收集

如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停。所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。这样就解决了长时间停顿的问题。

3. 闲时收集

垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响

#### 面试问题
1. 浏览器怎么进行垃圾回收？

因为垃圾回收时候会造成页面卡顿，所以再cpu空闲的时候，对不在被引用的对象进行垃圾回收（特殊情况就是一些对象互相引用，但是根断了引用，也是垃圾。全局变量随时可能用到，不是垃圾）。通过标记标记-清除算法，从根节点（Root）出发，遍历所有的对象。可以遍历到的对象，是可达（reachable）。没有被遍历到的对象，不可达的（unreachable），回收「不可达」的值所占据的内存。最后进行内存整理。

2. 浏览器中不同类型变量的内存都是何时释放？

javascritp 中类型：值类型，引用类型。引用类型：在没有引用之后。通过v8自动回收.值类型: 如果处于闭包的情况下，要等闭包没有引用才会被 V8 回收;非闭包的情况下，等待 V8 的新生代切换的时候回收

3. 哪些情况会导致内存泄露？如何避免？

内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，内侧无法释放，也不能被再次利用起来

常见的内存泄露：

* 意外的全局变量，比如在局部变量中没有用 var定义变量，使变量变成了全局的变量。
* 定时器设置了，后面不需要时没有清除定时器
* 脱离 DOM 的引用（详细可以去看相关博客）

Vue内存泄露,通常有这些情况:
* 监听在 window/body 等事件没有解绑
* 绑在 EventBus 的事件没有解绑
* Vuex 的 $store，watch 了之后没有 unwatch
* 使用第三方库创建，没有调用正确的销毁函数

解决办法：
* beforeDestroy 中及时销毁
* 绑定了 DOM/BOM 对象中的事件 addEventListener ，removeEventListener。
* 观察者模式 on ， on，on，off处理。
* 如果组件中使用了定时器，应销毁处理。
* 如果在 mounted/created 钩子中使用了第三方库初始化，对应的销毁。
* 使用弱引用 weakMap、weakSet。

4. weakMap weakSet 和 Map Set 有什么区别？

在 ES6 中为我们新增了两个数据结构 WeakMap、WeakSet，就是为了解决内存泄漏的问题。它的键名所引用的对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

5. 闭包会导致内存泄露吗

闭包会导致内存泄露吗？正确的答案是不会。（很多博客说会有内存泄露，大家可以去看看）内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。闭包里面的变量就是我们需要的变量，不能说是内存泄露。
