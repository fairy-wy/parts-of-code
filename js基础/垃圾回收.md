#### 前言
JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存

#### 什么是垃圾
一般来说没有被引用的对象就是垃圾（访问不到），就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。

例如
```js
// 1
let user = {
    name: 'john'
}
user = null // 此时john这个对象已经没有变量引用，因此就成了垃圾，等待被回收

// 2
let user = {
    name: 'kele'
}
let admin = user
user = null
// 此时kele这个对象还不能被回收，虽然user对他没有引用了，但是admin对他还有引用
```

#### 确认垃圾的方法

**1. 引用计数**

实现原理：

内部通过引用计数器，来维护当前对象的引用数，从而判断该对象的引用数是否为0，来决定它是否是一个垃圾对象。当引用数值为0,，GC就开始工作，将其所在的内存空间进行回收释放和再使用。

引用计数器

当某一个对象的引用关系发生改变时，引用计数器就会自动的修改这个对象所对应的引用数值（外部对该对象引用一次引用数值增加1，释放引用引用数值减1。） 引用数值为0的时候GC就开始工作，将当前的对象空间回收

优点

* 即时回收垃圾对象、减少程序卡顿时间。
* 最大限度的减少程序暂停（应用程序在执行的过程中必定会对内存进行消耗，而当前的执行平台内存空间是有上限的，所以内存肯定会有占满的时候。由于引用计数算法时刻监控着那些引用数值为0的对象，当内存爆满的时候会去找那些引用数值为0的对象释放其内存，尽可能的避免内存占满）

缺点

* 无法回收循环引用的对象（两个对象仅仅互相引用），资源消耗较大
* 时间开销大（当前的引用计数需要去维护一个数值的变化，时刻监控当前引用数值是否修改，修改需要时间）


**2. 可达性（reachability）分析**

将内存空间中能够被访问到的对象视为存活对象，对直接或者间接都访问不到的对象视为垃圾对象，在垃圾回收时将其内存释放回收。

实现原理：

* 从根节点（Root）出发，遍历内存空间中所有的对象。
* 可以遍历到的对象，标记为可达的（reachable）。
* 直接或者间接都被遍历不到的对象，是不可达的（unreachable）。
* 在浏览器环境下，根节点有很多，主要包括这几种（全局变量 window，位于每个iframe中文档 DOM 树，存放在执行栈上的变量）

优点：

* 避免了引用计数方式循环引用的缺陷，对垃圾对象的把控更精准

缺点： 

* 内存空间中的对象可能很多，遍历消耗大，速度慢

#### 垃圾回收算法

**1. 标记-清除**

将存活的对象进行标记，未标记的视为垃圾对象，将垃圾对象进行内清除，回收内存。

优点： 

* 直接清除，不需要移动对象，进行内存整理，所以速度快，效率高

缺点：

* 会产生大量不连续的内存碎片，如果需要分配较大的连续内存时，可能出现内存不足的情况

**2. 标记-整理**

将标记的存活对象移动到一起，整理出连续的内存空间，对存活对象以外的内存空间进行垃圾回收，释放内存

优点：

* 解决了内存碎片的缺陷，可以得到大片连续的内存空间，可容纳较大对象

缺点： 

* 需要进行对象的内存移动，对象的内存地址可能会被改变，效率低下

**3. 标记-复制**

将完整的内存空间一分为二，分成相同的两个部分；一部分为当前使用空间用于存放对象，另外一部分为空闲内存不存放对象，垃圾回收时，将当前使用空间标记的存活对象复制移动到空闲空间，然后回收当前使用空间；此时空闲空间变成了当前使用空间用于存放对象。

优点： 

* 不会出现内存碎片，有连续可使用的内存空间

缺点： 

* 内存空间被分成相同的两部分，使用的内存空间减少一半，垃圾回收频率会增多

#### 垃圾回收机制优化策略

**1. 分代收集**

浏览器将数据分为两种，一种是「临时」对象，一种是「长久」对象

临时对象：大部分对象在内存中存活的时间很短。（比如函数内部声明的变量，或者块级作用域中的变量。当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。）这类对象很快就变得不可访问，应该快点回收。

长久对象：生命周期很长的对象，比如全局的 window、DOM、Web API，垃圾回收超过15次没有被回收的对象等等。这类对象可以慢点回收。

这两种对象对应不同的回收策略，所以，V8 把堆分为新生代和老生代两个区域， 新生代中存放临时对象，老生代中存放持久对象。并且让副垃圾回收器、主垃圾回收器，分别负责新生代、老生代的垃圾回收。这样就可以实现高效的垃圾回收啦。

* 新生代

    * 对象占用空间小。
    * 对象存活时间短。

新生代采用标记-复制算法进行垃圾回收，因为新生代对象生命周期短，存活对象较少，使用标记-复制只需要付出少量的复制成本就可以完成垃圾回收

回收过程：

被标记的存活的对象被复制到空闲区域，并且将他们有序的排列一遍。复制完成后，对象区域会和空闲区域进行对调。将空闲区域中存活的对象放入对象区域里。这样，就完成了垃圾回收。因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置得比较小。一旦检测到空间装满了，就执行垃圾回收

* 老生代

    * 对象占用空间大。
    * 对象存活时间长。

老生代采用标记-清除结合标记-整理算法，因为老生代空间较大，垃圾回收没有那么频繁

**主垃圾回收器**

负责老生代的垃圾回收，有两个特点：

* 对象占用空间大。
* 对象存活时间长。

**2. 增量收集**

如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停。所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。这样就解决了长时间停顿的问题。


#### 面试问题

1. 浏览器怎么进行垃圾回收？

因为垃圾回收时候会造成页面卡顿，所以再cpu空闲的时候，对不在被引用的对象进行垃圾回收（特殊情况就是一些对象互相引用，但是根断了引用，也是垃圾。全局变量随时可能用到，不是垃圾）。通过标记标记-清除算法，从根节点（Root）出发，遍历所有的对象。可以遍历到的对象，是可达（reachable）。没有被遍历到的对象，不可达的（unreachable），回收「不可达」的值所占据的内存。最后进行内存整理。

2. 浏览器中不同类型变量的内存都是何时释放？

javascritp 中类型：值类型，引用类型。引用类型：在没有引用之后。通过v8自动回收.值类型: 如果处于闭包的情况下，要等闭包没有引用才会被 V8 回收;非闭包的情况下，等待 V8 的新生代切换的时候回收

3. 哪些情况会导致内存泄露？如何避免？

内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，内侧无法释放，也不能被再次利用起来

常见的内存泄露：

* 意外的全局变量，比如在局部变量中没有用 var定义变量，使变量变成了全局的变量。
* 定时器设置了，后面不需要时没有清除定时器
* 脱离 DOM 的引用（详细可以去看相关博客）

Vue内存泄露,通常有这些情况:
* 监听在 window/body 等事件没有解绑
* 绑在 EventBus 的事件没有解绑
* Vuex 的 $store，watch 了之后没有 unwatch
* 使用第三方库创建，没有调用正确的销毁函数

解决办法：
* beforeDestroy 中及时销毁
* 绑定了 DOM/BOM 对象中的事件 addEventListener ，removeEventListener。
* 观察者模式 on ， on，on，off处理。
* 如果组件中使用了定时器，应销毁处理。
* 如果在 mounted/created 钩子中使用了第三方库初始化，对应的销毁。
* 使用弱引用 weakMap、weakSet。

4. weakMap weakSet 和 Map Set 有什么区别？

在 ES6 中为我们新增了两个数据结构 WeakMap、WeakSet，就是为了解决内存泄漏的问题。它的键名所引用的对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

5. 闭包会导致内存泄露吗

闭包会导致内存泄露吗？正确的答案是不会。内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。闭包里面的变量就是我们需要的变量，不能说是内存泄露。
