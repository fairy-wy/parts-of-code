### 首屏加载

首屏加载时间是指浏览器从相应用户输入网址到首屏内容渲染完成的时间，从用户的角度来说就是：“地址栏输入网址之后网页呈现的速度”。整个网站并不需要全部加载完成，但需要展示当前可视窗口中的内容。

**首屏加载过程(白屏的过程)**

从输入url，到页面的画面展示的过程

1. 首先，在浏览器地址栏中输入url

2. 浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。

3. 在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。

4. 浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。

5. 握手成功后，浏览器向服务器发送http请求，请求数据包。

6. 服务器处理收到的请求，将数据返回至浏览器

7. 浏览器收到HTTP响应，读取页面内容，浏览器渲染，解析html源码

8. 生成Dom树、解析css样式、js交互,渲染显示页面

浏览器下载HTML后，首先解析头部代码，进行样式表下载，然后继续向下解析HTML代码，构建DOM树，同时进行样式下载。当DOM树构建完成后，立即开始构造CSSOM树。理想情况下，样式表下载速度够快，DOM树和CSSOM树进入一个并行的过程，当两棵树构建完毕，构建渲染树，然后进行绘制。

Tips:浏览器安全解析策略对解析HTML造成的影响：

* 当解析HTML时遇到内联JS代码，会阻塞DOM树的构建，会先执行完JS代码;当CSS样式文件没有下载完成时，浏览器解析HTML遇到了内联JS代码，此时，浏览器暂停JS脚本执行，暂停HTML解析。直到CSS文件下载完成，完成CSSOM树构建，重新恢复原来的解析。

* JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。

**首屏加载速度慢的原因**

* 网络延时问题
* 请求资源过多
* 资源文件体积是否过大问题
* 资源是否重复发送请求去加载问题
* 加载脚本的时候，渲染内容堵塞问题

**常见的SPA首屏优化方式**

* DNS解析优化
    1.DNS缓存优化
    2.DNS预加载策略
    3.稳定可靠的DNS服务器

* 减小入口文件体积

    1. 路由懒加载：以import函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件
    2. 减小文件大小：利用uglify+tree-shaking删除无用代码

* 静态资源本地缓存

    1. 前端合理利用localStorage
    2. 采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头(强缓存和弱缓存)

* UI框架按需加载

    1. 在日常使用UI框架，例如element-UI，我们按需引用。只引入需要的组件，以达到减小项目体积的目的

* 避免组件重复打包

    1. 使用optimization.splitChunks和optimization.runtimeChunk分割代码块

* 图片懒加载

    * 原理：图片只在准备下滑到其区域时，才发送请求加载图片。初始化时，图片标签的src不能是真实的图片地址，也不可以是空地址或者坏地址(会出现图片加载失败的图标)。初始化的时候，可以设置图片的src是某一个小型图片。例如一张1px*1px的透明图片。由于所有图片都使用这一张图片，只会发送一次请求，不会增加性能负担。将图片的真实路径绑定给一个自定义属性，例如data-url。注意：页面的img元素，如果没有src属性，浏览器就不会发出请求去下载图片。定义滚动事件，判断元素进入视口，则将src替换为真正的url地址。利用js提取data-url的真实图片地址赋值给src属性。

* 图片资源的压缩

    1. 使用icon等在线字体和雪碧图
    2. 配置webpack中的url-loader中设置的limit大小来对图片进行处理，小于limit的图片转化成base64格式，其余的不做操作。
    3. 对于比较大的图片我们可以用image-webpack-loader 来压缩图片

* 开启GZip压缩

* 使用SSR服务端渲染，

    * 也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器。SSR技术会实现将指定的异步数据在服务端渲染好，再返回给客户端，这样就减轻了客户端的请求异步数据的压力，渲染页面就更快了。
    * vue可使用Nuxt.js框架实现服务端渲染
    * react多采用koa2等技术的实现方案。


